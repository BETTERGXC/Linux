# 线程池

**线程池 = 线程安全的队列 + 一大堆的线程（消费线程）**



## 线程池当中的线程，都是同一种角色的线程。就是说每一个线程都执行同样的入口函数。但是如果线程池中的线程都是执行同一个入口函数的话，执行的功能就比较单一，如何去满足大量的业务需求？

1. switch case: 处理大量不同需求的时候，比较麻烦

2. 向线程池抛入数据的时候，将处理该数据的函数一起抛入（函数地址），线程池当中的线程只需要调用传入的函数处理传入的数据即可

   

## 线程从队列里边拿数据和处理业务分开写的原因是（不在队列Pop函数中运行线程回调函数）：

​	如果从队列中拿数据和处理业务混合在一起了

​	假设如果处理数据特别漫长，就只有一个线程在处理数据，而其他线程在等待获取队列当中元素

​	采用的方式：将从队列中拿数据和业务处理解耦开来

​	加锁的时候：只需要保证拿数据的时候是互斥的

​	处理业务数据的时候，多个线程可以并行的去运行



## 如何让线程池中的线程优雅的退出

背景：担心线程直接退出，而导致线程池当中线程安全队列里面还有数据没有被处理

线程池当中可能存在的几种情况

1. 加互斥锁

2. 调用pthread_cond_wait当中

3. 在队列当中获取数据

4. 正在处理队列里边的数据

结论：只有当线程判断了队列当中没有数据的情况下才可以退出

做法：当任务队列为空，并且退出标志为真，在循环中一步一步减少线程数，最后退出线程池，参考threadpool.hpp中thr_start和PoolQuit函数